\documentclass[a4paper,11pt]{article}

% fonts
\usepackage[utf8]{inputenc}
%\usepackage[francais]{babel}

% to get hyphenation on accented words
\usepackage[T1]{fontenc}

% href
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=blue,      
    urlcolor=blue,
    bookmarks=true
}

% quotes
\usepackage{csquotes}

% code highlighting
\usepackage{minted}
\usemintedstyle{pastie}

% asm
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

% inline code
\usepackage{listings}
\usepackage{xcolor}

% tables
\usepackage{booktabs}

% algorithm
\usepackage[]{algorithm2e}

% for right cases
\newenvironment{rcases}
  {\left.\begin{aligned}}
  {\end{aligned}\right\rbrace}
  
% images
\usepackage{graphicx}
\usepackage{float}

% diagrams
\usepackage{tikz}
\usetikzlibrary{matrix}
\usetikzlibrary{positioning}

% tables
\usepackage{booktabs}

% no identation
\setlength{\parindent}{0pt}

% theorem
\newtheorem{definition}{Definition}
\newtheorem{property}{Property}
\newtheorem{theorem}{Theorem}

% header
\title{How to backdoor Diffie-Hellman, lessons learned from the Socat non-prime prime}
\author{David Wong}
\date{\emph{NCC Group}, \small{February 2016}}

% 
\begin{document}

\maketitle

\renewcommand{\abstractname}{Abstract}
\begin{abstract}
A few months after Juniper's infamous and subtle vulnerability at the end of 2015, A similar fine tuning happened in an open source tool called Socat. Juniper's cryptographic vulnerability was found to have birthed from the change of a simple number later identified as a Dual EC parameter (NSA's backdoored Pseudo-Random Number Generator). Socat's own change of number happened to be in its implementation of the Diffie-Hellman key exchange. This paper aims to introduce the point of view of a malicious commiter who would want to introduce a Nobody-But-Us backdoor in the later public key cryptosystem he has access to.\\
\\
\textbf{Keywords:} Juniper, Socat, NOBUS, backdoor, Dual EC, Diffie-Hellman, Small subgroup attack, Pohlig-Hellman, Factorization, Pollard's p-1 algorithm, ECM\\

\end{abstract}

\section{Introduction}\label{introduction}

Around Christmas 2015, a company named \emph{Juniper} released an \href{https://kb.juniper.net/InfoCenter/index?page=content&id=JSA10713&actp=search}{out of cycle security bulletin}. Two vulnerabilities were being half-disclosed, without much details to help us grasp the seriousness of the situation. Fortunately, at this period of the year many researchers were home with nothing else to do but to try  solving this puzzle. Quickly, by diffing both the patched and vulnerable binaries, the two issues were pinpointed. While one of the vulnerability was a simple super password implemented at a crucial step of the product's authentication, the other vulnerability discovered was a bit more subtle: a value was modified. More accurately, a number was replaced. The introduction of the vulnerability was so trivial that the simple use of the unix commandline tool \mintinline{bash}{strings} was enough to discover the change.

\begin{figure}[H]
\centering
\includegraphics[scale=.6]{screenOS.png}
\caption{The Juniper's Security Bulletin}\label{screenOS}
\end{figure}

Behind that modified number was hiding a \emph{Dual EC} value. Dual EC is a Pseudo-Random Number Generator (PRNG) that is believed to have been backdoored by the NSA \cite{dualEC}. The PRNG's core has the ability to provide a Nobody But Us (NOBUS) trapdoor: a secret passage that can only be accessed by the people holding the secret key. In our case: the elliptic curve discrete logarithm $k$ in the Dual EC equation $Q = [k]P$ (where $P$ and $Q$ are the two elliptic curve points used in the foundation of Dual EC).\\

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{screenOS2.png}
\caption{The Juniper's Security Bulletin}\label{screenOS}
\end{figure}

Although the quest to find the Juniper's backdoor and the numerous open questions that arose from that work are a fascinating read by itself \cite{juniper}, it is only the introduction of this work that aims to show how secure and strong cryptographic constructions are a simple and subtle change away from being your own secretive pipe-show.\\

On February the 1st 2016, only a few months after Juniper's debacle, \emph{Socat} \href{http://www.openwall.com/lists/oss-security/2016/02/01/4}{published a security advisory of its own}.

\begin{displayquote}
In the OpenSSL address implementation the hard coded 1024 bit DH p parameter was not prime. The effective cryptographic strength of a key exchange using these parameters was weaker than the one one could get by using a prime p. Moreover, since there is no indication of how these parameters were chosen, the existence of a trapdoor that makes possible for an eavesdropper to recover the shared secret from a key exchange that uses them cannot be ruled out.\\
A new prime modulus p parameter has been generated by Socat developer using OpenSSL dhparam command.\\
In addition the new parameter is 2048 bit long
\end{displayquote}

This is alerting. In the same vein of Juniper's problem, a single number was changed. But Socat's problems root deeper. A year before that suspicious 1024 bit Diffie-Hellman (DH) value was introduced, the free software would have served its TLS connection using a 512 bit DH modulus. The problem with such small DH parameters is already well known \cite{logjam}, but the problems of implementing DH securely are unfortunately rarely well understood. The defense approach is told in several RFCs \cite{rfc2631} \cite{rfc2785}, but no paper so far take the point of view of the attacker.\\

In section 2, we will first discard some possible mistakes that the troublemaker could have made. In section 3 we will introduce the different attacks available on DH, from small subgroup attacks to Pohlig Hellman's algorithm. We will start by explaining how to implement a NOBUS backdoor in Diffie-Hellman in section 4, and we will follow with the bulk of our contribution in section 5: that is the different methods to achieve that goal. In section 6 we will see what's wrong with the previous methods, and use what we learned from that to try to reverse Socat's 1024 bit DH modulus. Informationally, we will test the security of the new 2048 bit DH modulus of Socat in section 7, and follow by brief explanations on how to secure a DH implementation. Eventually we will wrap it all in section 9.

\section{Human error}\label{mistake}

Before shouting from the rooftops the words "backdoor", let's take a step back and imagine what could have gone wrong. First, it is possible that \href{http://repo.or.cz/socat.git/commitdiff/281d1bd6515c2f0f8984fc168fb3d3b91c20bdc0}{the poor man who suggested the change} (back then an \emph{Oracle} employee) had no idea that the DH modulus should be a prime. In fact, Diffie-Hellman works well enough with composite modulus (but keep in mind that it has its share of problems, and we will see later why). 

It might comes as a shock to the non-enlightened, but we usually do not take the time to generate real primes, or what we more generally call \textem{provable} primes. Efficient provable tests like ECPP or AKS \cite{ecpp} do exists, but the accuracy and the speed of \textem{probable} tests (tests that either tell you if a number is not a prime, or probably a prime) are good enough that any margin of error is negligible.

Examples of probable tests are given in appendix C.3 of the  \href{http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf}{FIPS 186 document}. Most implementations will use the \textem{Miller-Rabin} test with a variable amount of iteration according to the degree of certainty they want to achieve.

--

TALK ABOUT PROBABILITY TO FAIL THIS TEST
>  2^-80 (~10^24) is is about as likely as being hit by a meteorite (~10^-16)[1] at exactly the same moment you are learning that you won the Powerball (~10^-8). Alternatively, it is as likely as winning Powerball in three consecutive drawings.

--

* Ways we verified that it could have been a mistake (little endian, blablabla)

> Multiple byte data
   items are concatenations of bytes, from left to right, from top to
   bottom.
   ...
> This byte ordering for multi-byte values is the commonplace network
   byte order or big-endian format.
   https://www.ietf.org/rfc/rfc5246.txt

* Ways the primality test could have been wrong -> show that you have more chance winning the superball blabla (check HN thread for that)

Let's think, before leaving this section, how a non-malicious, mistakenly, badly generated composite modulus, should be distributed (and we will later come back to this):

From Handbook of Applied Cryptography fact 3.7:

    Let n be chosen uniformly at random form the interval 1, x if 1/2 <= a <= 1, then the probability that the largest prime factor of n is <= x^a is approximately 1+ ln(a). Thus, for example, the probability than n has a prime factor > sqrt(x) is ln(2) ~= 0.69 (ii) The probability that the second-largest prime factor of n is <= x^{0.2117} is about 1/2 (iii) The expected total number of prime factors of n is ln ln x + O(1). (If n = mult(p_i^{e_i}), the total number of prime factors of n is sum(e_i).)

So, let's think with numbers:

APPLICATION OF CALCULUS FOR OUR SIZE OF MODULUS


-- note --

from hn:


a) knew it was non-prime, and used it to weaken the crypto

b) knew it was non-prime, and used it because they didn't think it needed to be prime (which is a massive sin of ignorance)

c) grabbed 1024 bits of rand() and didn't check if it was prime (again, stupid)

d) grabbed some rand and checked the prime-ness using a bad method

e) used a "prime number generator" that produced bad output


\section{A prime modulus}

while DH can work on any kind of subgroup, the security of composite modulus subgroup are usually not as high as their prime counterparts. The primary reasons are smalls subgroup attack and Pohlig Hellman.

But first, prime or not prime, let's see one problem: what happens if the order of the group created has a "smooth" order (we will see it doesn't have to be smooth per se)

Def. Smooth:

\subsection{CRT}

CRT is a magic cryptanalyis tool. Like lattices for smaller values than the normal, SAT, GNFS, ...

graph to explain how it works

\subsection{Small subgroup attacks}

http://citeseerx.ist.psu.edu/viewdoc/download?rep=rep1&type=pdf&doi=10.1.1.44.5296

(d'un autre lien)> The small subgroup attack was first pointed out by Vanstone[26]; see also van Oorschot and Wiener [36], Anderson and Vaudenay [1], and Lim and Lee [22].

if the order is a composite of small subgroups

why not getting the discrete log in different subgroup and recombine it with CRT? That sounds easier that getting the discrete log in the whole group

\subsection{Pohlig Hellman}

> Static Diffie-Hellman keys are vulnerable to a small subgroup attack

The previous attack is "impractical" because DH is usually used as DHE (ephemeral keys). And since it is an active attack where we need to do several "handshake" (is this called a handshake?)

Pohlig Hellman is a passive attack, and spying on only one conversation allows you to decrypt the rest

same idea, but instead we will just use one public key and reduce it to different subgroups with a magic operation

note: in theory we can't reduce if we're in a smaller group, we can't "escape", we can only go in small subgroups

\section{How to implement a backdoor in DH}

we could use what we saw previously as such:

generate a prime such that the order of the generated group is p-1 a composites where the dlog is "do-able" in its subgroups. We don't need smooth. Doable is defined by your the computation power of the backdoor creator

But then anyone is able to get the order of the group (p-1) and can then factor that order. [[dlog in k bits is factor in 2 kbits no? Check complexities of these]]

It is believed by some that the NSA is a bit more classy than that and would create what we call "Nobody But Us" types of backdoor. That is nobody can reverse them. This was the case of Dual EC (although Dual EC suffered from slowness and bit biases even without the backdoor)

A good way of doing that is to use a non-prime modulus, this way the order would be $\phi(n)$ which is not p-1 anymore (give the formula)

fact: (the one from handbook of applied crypto)
the dlog in Z_n)* reduces to the combination of factorization of n and dlog in Z_p)* for each p factor of n

so people who would want to reverse the backdoor would first have to factor n to guess the order.

\section{Methods to create a backdoor} title)}

\subsection{method 1}

creating a backdoor method 1: p = p_1 p_2 where p_i - 1 smooth

\subsection{Method 2}

\subsection{Method 3}

\section{Methods to reverse the backdoor}

\subsection{trial division}

we found 271 and...

\subsection{pollard p-1}

such a construction as method1 allows for p-1 pollard to work.

\subsubsection{explanation}

explanation of pollard p-1

\subsubsection{results}

We tried it on a proof of concept and: RESULT

we then tried it on socat's dh1024_p and: RESULT

\subsection{ECM}

not tied to the modulus size, but tied to the smallest factor

on our proof of concet: RESULT

on socat's dh1024_p: RESULT

\section{Testing the security of the new modulus}

it was done p = 2q + 1 with q prime

secure

\section{How to secure a DH implementation}

- if the p = 2q + 1 is not done like that, there is a RFC that tells you how to secure such DH (safe prime, or is it Sophie Germaine prime? Or strong prime?)

- openssl dhparam

- also some people believe generation of prime is too difficult and that it shouldn't be possible (rfc with predefined dh groups). But then weakdh (or was it logjam rather), everybody used the same hardcoded dh prime, everybody could have/got owned

- verification of public key (but there is a patent on that? According to the diffie-hellman RFC)

- generation of safe prime

\section{Conclusion}

- implementing DH correctly is not that hard
- easy to backdoor
- is it really a backdoor? Since we can't factor it... maybe not (maybe give estimations to factor it, and to use the backdoor if it is indeed a backdoor with such big factors)
- people need to verify open source

\newpage

\section*{Acknowledgements}


\newpage

\begin{thebibliography}{1}

\bibitem{dualEC} Bernstein, Lange and Niederhagen \href{https://eprint.iacr.org/2015/767.pdf}{Dual EC: A Standardized Back Door}

\bibitem{juniper} Juniper {\em Juniper}

\bibitem{logjam} Adrian, Bhargavan, Durumeric, Gaudry, Green, Halderman, Heninger, Springall, Thomé, Valenta,  VanderSloot, Wustrow, Zanella-Béguelin, Zimmermann \href{https://weakdh.org/imperfect-forward-secrecy-ccs15.pdf}{Imperfect Forward Secrecy: How Diffie-Hellman Fails in Practice}

\bibitem{rfc2631} RFC 2631: \href{https://tools.ietf.org/html/rfc2631}{Diffie-Hellman Key Agreement Method}

\bibitem{rfc2785} RFC 2785: \href{https://tools.ietf.org/html/rfc2785}{Methods for Avoiding the "Small-Subgroup" Attacks on the Diffie-Hellman Key Agreement Method for S/MIME}

\bibitem{ecpp} Frank Li \href{http://theory.stanford.edu/~dfreeman/cs259c-f11/finalpapers/primalityproving.pdf}{An Overview of Elliptic Curve Primality Proving}

\end{thebibliography}

\end{document}