\documentclass[a4paper,11pt]{article}

% fonts
\usepackage[utf8]{inputenc}
%\usepackage[francais]{babel}

% to get hyphenation on accented words
\usepackage[T1]{fontenc}

% href
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=blue,      
    urlcolor=blue,
    bookmarks=true
}

% quotes
\usepackage{csquotes}

% code highlighting
\usepackage{minted}
\usemintedstyle{pastie}

% asm
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

% inline code
\usepackage{listings}
\usepackage{xcolor}

% tables
\usepackage{booktabs}

% algorithm
\usepackage[]{algorithm2e}

% for right cases
\newenvironment{rcases}
  {\left.\begin{aligned}}
  {\end{aligned}\right\rbrace}
  
% images
\usepackage{graphicx}
\usepackage{float}

% diagrams
\usepackage{tikz}
\usetikzlibrary{matrix}
\usetikzlibrary{positioning}

% tables
\usepackage{booktabs}

% no identation
\setlength{\parindent}{0pt}

% theorem
\newtheorem{definition}{Definition}
\newtheorem{property}{Property}
\newtheorem{theorem}{Theorem}

% header
\title{How to backdoor Diffie-Hellman, lessons learned from the Socat non-prime prime}
\author{David Wong}
\date{\emph{NCC Group}, \small{February 2016}}

% 
\begin{document}

\maketitle

\renewcommand{\abstractname}{Abstract}
\begin{abstract}
A few months after Juniper's infamous and subtle vulnerability at the end of 2015, A similar fine tuning happened in an open source tool called Socat. Juniper's cryptographic vulnerability was found to have birthed from the change of a simple number later identified as a Dual EC parameter (NSA's backdoored Pseudo-Random Number Generator). Socat's own change of number happened to be in its implementation of the Diffie-Hellman key exchange. This paper aims to introduce the point of view of a malicious commiter who would want to introduce a Nobody-But-Us backdoor in the later public key cryptosystem he has access to.\\
\\
\textbf{Keywords:} Juniper, Socat, NOBUS, backdoor, Dual EC, Diffie-Hellman, Small subgroup attack, Pohlig-Hellman, Factorization, Pollard's p-1 algorithm, ECM\\

\end{abstract}

\section{Introduction}\label{introduction}

Around Christmas 2015, a company named \emph{Juniper} released an \href{https://kb.juniper.net/InfoCenter/index?page=content&id=JSA10713&actp=search}{out of cycle security bulletin}. Two vulnerabilities were being half-disclosed, without much details to help us grasp the seriousness of the situation. Fortunately, at this period of the year many researchers were home with nothing else to do but to try  solving this puzzle. Quickly, by diffing both the patched and vulnerable binaries, the two issues were pinpointed. While one of the vulnerability was a simple super password implemented at a crucial step of the product's authentication, the other vulnerability discovered was a bit more subtle: a value was modified. More accurately, a number was replaced. The introduction of the vulnerability was so trivial that the simple use of the unix commandline tool \mintinline{bash}{strings} was enough to discover the change.

\begin{figure}[H]
\centering
\includegraphics[scale=.6]{screenOS.png}
\caption{The Juniper's Security Bulletin}\label{screenOS}
\end{figure}

Behind that modified number was hiding a \emph{Dual EC} value. Dual EC is a Pseudo-Random Number Generator (PRNG) that is believed to have been backdoored by the NSA \cite{dualEC}. The PRNG's core has the ability to provide a Nobody But Us (NOBUS) trapdoor: a secret passage that can only be accessed by the people holding the secret key. In our case: the elliptic curve discrete logarithm $k$ in the Dual EC equation $Q = [k]P$ (where $P$ and $Q$ are the two elliptic curve points used in the foundation of Dual EC).\\

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{screenOS2.png}
\caption{The Juniper's Security Bulletin}\label{screenOS}
\end{figure}

Although the quest to find the Juniper's backdoor and the numerous open questions that arose from that work are a fascinating read by itself \cite{juniper}, it is only the introduction of this work that aims to show how secure and strong cryptographic constructions are a simple and subtle change away from being your own secretive pipe-show.\\

On February the 1st 2016, only a few months after Juniper's debacle, \emph{Socat} \href{http://www.openwall.com/lists/oss-security/2016/02/01/4}{published a security advisory of its own}.

\begin{displayquote}
In the OpenSSL address implementation the hard coded 1024 bit DH p parameter was not prime. The effective cryptographic strength of a key exchange using these parameters was weaker than the one one could get by using a prime p. Moreover, since there is no indication of how these parameters were chosen, the existence of a trapdoor that makes possible for an eavesdropper to recover the shared secret from a key exchange that uses them cannot be ruled out.\\
A new prime modulus p parameter has been generated by Socat developer using OpenSSL dhparam command.\\
In addition the new parameter is 2048 bit long
\end{displayquote}

This is alerting. In the same vein of Juniper's problem, a single number was changed. But Socat's problems root deeper. A year before that suspicious 1024 bit Diffie-Hellman (DH) value was introduced, the free software would have served its TLS connection using a 512 bit DH modulus. The problem with such small DH parameters is already well known \cite{logjam}, but the problems of implementing DH securely are unfortunately rarely well understood. The defense approach is told in several RFCs \cite{rfc2631} \cite{rfc2785}, but no paper so far take the point of view of the attacker.\\

In section 2, we will first discard some possible mistakes that the troublemaker could have made. In section 3 we will introduce the different attacks available on DH, from small subgroup attacks to Pohlig Hellman's algorithm. We will start by explaining how to implement a NOBUS backdoor in Diffie-Hellman in section 4, and we will follow with the bulk of our contribution in section 5: that is the different methods to achieve that goal. In section 6 we will see what's wrong with the previous methods, and use what we learned from that to try to reverse Socat's 1024 bit DH modulus. Informationally, we will test the security of the new 2048 bit DH modulus of Socat in section 7, and follow by brief explanations on how to secure a DH implementation. Eventually we will wrap it all in section 9.

\section{Human error}\label{mistake}

Before shouting from the rooftops the words "backdoor", let's take a step back and imagine what could have gone wrong. First, it is possible that \href{http://repo.or.cz/socat.git/commitdiff/281d1bd6515c2f0f8984fc168fb3d3b91c20bdc0}{the poor man who suggested the change} (back then an \emph{Oracle} employee) had no idea that the DH modulus should be a prime. In fact, Diffie-Hellman works well enough with composite modulus (but keep in mind that it has its share of problems, and we will see later why). Also, what if he did generated a prime but got lost afterwards?\\

Throughout TLS \cite{tls12}, and in Socat's case throughout OpenSSL, the use of \emph{big endianness} is enforced for long numbers formatting. That is: you read a byte string from left to right to convert it to a number. This can make the process of converting from and to numbers a confusing task.

\begin{figure}[H]
\begin{minted}[breaklines,frame=single]{c}
static unsigned char dh1024_p[] = {
   0xCC, 0x17, 0xF2, 0xDC, 0x96, 0xDF, 0x59, 0xA4, 0x46, 0xC5, 0x3E, 0x0E, 
   0xB8, 0x26, 0x55, 0x0C, 0xE3, 0x88, 0xC1, 0xCE, 0xA7, 0xBC, 0xB3, 0xBF, 
   0x16, 0x94, 0xD8, 0xA9, 0x45, 0xA2, 0xCE, 0xA9, 0x5B, 0x22, 0x25, 0x5F, 
   0x92, 0x59, 0x94, 0x1C, 0x22, 0xBF, 0xCB, 0xC8, 0xC8, 0x57, 0xCB, 0xBF, 
   0xBC, 0x0E, 0xE8, 0x40, 0xF9, 0x87, 0x03, 0xBF, 0x60, 0x9B, 0x08, 0xC6, 
   0x8E, 0x99, 0xC6, 0x05, 0xFC, 0x00, 0xD6, 0x6D, 0x90, 0xA8, 0xF5, 0xF8, 
   0xD3, 0x8D, 0x43, 0xC8, 0x8F, 0x7A, 0xBD, 0xBB, 0x28, 0xAC, 0x04, 0x69, 
   0x4A, 0x0B, 0x86, 0x73, 0x37, 0xF0, 0x6D, 0x4F, 0x04, 0xF6, 0xF5, 0xAF, 
   0xBF, 0xAB, 0x8E, 0xCE, 0x75, 0x53, 0x4D, 0x7F, 0x7D, 0x17, 0x78, 0x0E, 
   0x12, 0x46, 0x4A, 0xAF, 0x95, 0x99, 0xEF, 0xBC, 0xA6, 0xC5, 0x41, 0x77, 
   0x43, 0x7A, 0xB9, 0xEC, 0x8E, 0x07, 0x3C, 0x6D, 
};
\end{minted}
\caption{Socat's 1024 bit DH non-prime prime}
\label{fig:cert}
\end{figure}

Passed to OpenSSL, this big number is read from left to right as the long hexstring. Passed through a primality test this is indeed a composite number.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{prime1.png}
\end{figure}

A natural question we could ask ourselves is that maybe the rogue commiter could have reversed the hexstring? Testing for that yielded a composite number as well.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{prime2.png}
\end{figure}

What if everything was reversed? Even inside the byte

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{prime3.png}
\end{figure}

Another one, is that maybe the prime number was too long and thus truncated to 1024 bit (since the program was asking for a 1024 bit number). Indeed, the following number is a prime:

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{prime4.png}
\end{figure}

It might comes as a shock to the non-enlightened, but we usually do not take the time to generate real primes, or what we more generally call \emph{provable} primes. Efficient provable tests like ECPP or AKS \cite{ecpp} do exists, but the accuracy and the speed of \emph{probable} tests (tests that either tell you if a number is not a prime, or probably a prime) are good enough that any margin of error is negligible.

Examples of probable tests are given in appendix C.3 of the  \href{http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf}{FIPS 186 document}. Most implementations will use the \emph{Miller-Rabin} test with a variable amount of iteration according to the degree of certainty they want to achieve.

For example in \href{https://www.openssl.org/docs/manmaster/crypto/BN_generate_prime.html}{Openssl's \mintinline{c}{BN_is_prime_fasttest_ex()} function}, the number of iteration is chosen such that the risk of yielding a false positive (a non-prime prime) is of at most $1/2^{80}$. To understand what this means in practice: it is as likely to happen as being hit by a meteorite while winning the Powerball. Here's a quote from the Structure and Interpretation of Computer Programs book \cite{sicp}:

\begin{displayquote}
Numbers that fool the Fermat test are called Carmichael numbers, and little is known about them other than that they are extremely rare. There are 255 Carmichael numbers below 100,000,000. The smallest few are 561, 1105, 1729, 2465, 2821, and 6601. In testing primality of very large numbers chosen at random, the chance of stumbling upon a value that fools the Fermat test is less than the chance that cosmic radiation cosmic radiation will cause the computer to make an error in carrying out a "correct" algorithm. Considering an algorithm to be inadequate for the first reason but not for the second illustrates the difference between mathematics and engineering.
\end{displayquote}

This is to say: the Oracle developer probably didn't intend to generate a prime.

\section{Reasons for a prime modulus}

while DH can work in any kind of integer group, there are subtle reasons behind the choice of a prime group. But prime or not prime, if the modulus is not chosen correctly, this can lead to the fact that the order of the multiplicative group is "smooth" (we will see it doesn't have to be smooth per se)

Def. Smooth:

If the order is smooth, two attacks on DH are then possible.

We'll see that:

\subsection{The Chinese Remainder Theorem}

Along LLL, SAT solvers, GNFS and Pollard's Rho, the \emph{Chinese Remainder Theorem} (CRT) is one of the magic tool of a cryptanalyst.

This tool sometimes used for the good (RSA-CRT\footnote{ Shinde, Fadewar \href{http://www.techscience.com/doi/10.3970/icces.2008.005.255.pdf}{Faster RSA Algorithm for Decryption Using Chinese
Remainder Theorem}}\cite{fasterRSA} is a construction where CRT is used to speed up RSA decryption) is also often used for the bad. But first let's see how it works:

\begin{theorem}
Suppose $m = \prod^{k} m_i$ with $m_1, \cdots, n_k$ pairwise co-prime.\\

For any $(a_1, \cdots, a_k)$ there exists a $x$ such that:\\

\begin{cases}
x= a_1 \pmod{m_1}\\
\vdots\\
x= a_k \pmod{m_k}\\
\end{cases}\\

And there exist a unique solution for $x \pmod{m}$
\end{theorem}

There is a simple proof to that theorem which we will use to later reconstruct a $x \pmod{m}$ in the attack (note that I called the modulus $m$ so that you don't get any ideas that we will later use CRT with a DH modulus). Here goes the proof:

\begin{proof}
\begin{equation*}
x = \sum^{k} a_i * (\prod^{j \neq i} m_j (m_j^{-1} \pmod{m_i}))  \pmod{m}
\end{equation*}
\end{proof}\\

At first, it might be kind of hard to grasp where that formula is coming from. But let me explain by starting with only two equations. Keep in mind that we want to find the value of $x$ modulo $m = m_1 m_2$

\[
\begin{rcases}
x = a_1 \pmod{m_1}\\
x = a_2 \pmod{m_2}
\end{rcases}
\implies x = \text{ ?} \pmod{m}
\]\\

How can we start building the value of $x$?
\begin{multline}
\begin{aligned}
&\text{If } x = a_1  m_2\pmod{m} \text{,}\\
&\text{then }
\begin{cases}
x = \boldsymbol{a_1} m_2 \pmod{m_1}\\
x = \boldsymbol{0} \pmod{m_2}\\
\end{cases}\\
\end{aligned}
\end{multline}

Quite not what we want, but we are getting there. Let's add to it:
\begin{multline}
\begin{aligned}
&\text{If } x = a_1  m_2  (m_2^{-1} \pmod{m_1}) \pmod{m}\\
&\text{then } \begin{cases}
x = a_1 m_2 (m_2^{-1} \pmod{m_1}) = \boldsymbol{a_1} \pmod{m_1}\\
x = 0 \pmod{m_2}\\
\end{cases}\\
&\text{with } $m_2{-1} \pmod{m_1}$ \text{the inverse of} $m_2$ \text{modulo} $m_1$\text{.}
\end{aligned}
\end{multline}

That's almost what we want! Half of what we want actually. We just need to do the same thing for the other side of the equation, and we have:

\[ x = a_1 m_2 (m_2^{-1} \pmod{m_1}) + a_2 m_1 (m_1^{-1} \pmod{m_2}) \pmod{m} \]

Now you should understand better how we came with that big formula in the proof.

\subsection{Small subgroup attacks}

What if we could use the CRT to attack DH?

http://citeseerx.ist.psu.edu/viewdoc/download?rep=rep1&type=pdf&doi=10.1.1.44.5296

(d'un autre lien)> The small subgroup attack was first pointed out by Vanstone[26]; see also van Oorschot and Wiener [36], Anderson and Vaudenay [1], and Lim and Lee [22].

if the order is a composite of small subgroups

why not getting the discrete log in different subgroup and recombine it with CRT? That sounds easier that getting the discrete log in the whole group

\subsection{Pohlig Hellman}

> Static Diffie-Hellman keys are vulnerable to a small subgroup attack

The previous attack is "impractical" because DH is usually used as DHE (ephemeral keys). And since it is an active attack where we need to do several "handshake" (is this called a handshake?)

Pohlig Hellman is a passive attack, and spying on only one conversation allows you to decrypt the rest

same idea, but instead we will just use one public key and reduce it to different subgroups with a magic operation

note: in theory we can't reduce if we're in a smaller group, we can't "escape", we can only go in small subgroups

\section{How to implement a backdoor in DH}

we could use what we saw previously as such:

generate a prime such that the order of the generated group is p-1 a composites where the dlog is "do-able" in its subgroups. We don't need smooth. Doable is defined by your the computation power of the backdoor creator

But then anyone is able to get the order of the group (p-1) and can then factor that order. [[dlog in k bits is factor in 2 kbits no? Check complexities of these]]

It is believed by some that the NSA is a bit more classy than that and would create what we call "Nobody But Us" types of backdoor. That is nobody can reverse them. This was the case of Dual EC (although Dual EC suffered from slowness and bit biases even without the backdoor)

A good way of doing that is to use a non-prime modulus, this way the order would be $\phi(n)$ which is not p-1 anymore (give the formula)

fact: (the one from handbook of applied crypto)
the dlog in Z_n)* reduces to the combination of factorization of n and dlog in Z_p)* for each p factor of n

so people who would want to reverse the backdoor would first have to factor n to guess the order.

\section{Methods to create a backdoor} title)}

\subsection{method 1}

creating a backdoor method 1: p = p_1 p_2 where p_i - 1 smooth

\subsection{Method 2}

\subsection{Method 3}

\section{Methods to reverse the backdoor}

\subsection{trial division}

we found 271 and 13,597

\subsection{pollard p-1}

such a construction as method1 allows for p-1 pollard to work.

\subsubsection{explanation}

explanation of pollard p-1

\subsubsection{results}

We tried it on a proof of concept and: RESULT

we then tried it on socat's dh1024_p and: RESULT

\subsection{ECM}

not tied to the modulus size, but tied to the smallest factor

on our proof of concet: RESULT

on socat's dh1024_p: RESULT

\section{Estimations}

How does a non-malicious, mistakenly, badly generated composite modulus, should be distributed (and we will later come back to this):

From \href{http://cacr.uwaterloo.ca/hac/about/chap3.pdf}{Handbook of Applied Cryptography fact 3.7}:

\begin{definition}
    Let $n$ be chosen uniformly at random form the interval $[1, x]$.
    \begin{enumerate}
        \item if $1/2 \leq \alpha \leq 1$, then the probability that the largest prime factor of $n$ is $\leq x^{\alpha}$ is approximately $1+ ln(\alpha)$. Thus, for example, the probability than $n$ has a prime factor $> \sqrt(x)$ is $ln(2) \approx 0.69$
        \item The probability that the second-largest prime factor of $n$ is $\leq x^{0.2117}$ is about $1/2$. 
        \item The expected total number of prime factors of $n$ is $ln ln x + \mathcal{O}(1)$. (If $n = \prod p_i^{e_i}$, the total number of prime factors of n is $\sum e_i$.)
    \end{enumerate} 
\end{definition}

And since it might be easier to visualize this with numbers:

\begin{enumerate}
    \item socat's 1024 bit composite modulus $n$ probability to have a prime factor greater than 512 bits is $\approx 0.69$.
    \item the probability that the second-largest prime factor of $n$ is smaller than 217 bits is $1/2$.
    \item The total number of prime factor of $n$ is expected to be $7$.
\end{enumerate}


we ran ECM and pollard p-1 on two machines [descript of machine] with no results

\section{The new modulus and how to secure a DH implementation}

new modulus=it was done p = 2q + 1 with q prime


- if the p = 2q + 1 is not done like that, there is a RFC that tells you how to secure such DH (safe prime, or is it Sophie Germaine prime? Or strong prime?)

- openssl dhparam

- also some people believe generation of prime is too difficult and that it shouldn't be possible (rfc with predefined dh groups). But then weakdh (or was it logjam rather), everybody used the same hardcoded dh prime, everybody could have/got owned

- verification of public key (but there is a patent on that? According to the diffie-hellman RFC)

- generation of safe prime


\section{Conclusion}

- implementing DH correctly is not that hard
- easy to backdoor
- is it really a backdoor? Since we can't factor it... maybe not (maybe give estimations to factor it, and to use the backdoor if it is indeed a backdoor with such big factors)
- people need to verify open source

\newpage

\section*{Acknowledgements}


\newpage

\begin{thebibliography}{1}

\bibitem{dualEC} Bernstein, Lange and Niederhagen \href{https://eprint.iacr.org/2015/767.pdf}{Dual EC: A Standardized Back Door}

\bibitem{juniper} Juniper {\em Juniper}

\bibitem{logjam} Adrian, Bhargavan, Durumeric, Gaudry, Green, Halderman, Heninger, Springall, Thomé, Valenta,  VanderSloot, Wustrow, Zanella-Béguelin, Zimmermann \href{https://weakdh.org/imperfect-forward-secrecy-ccs15.pdf}{Imperfect Forward Secrecy: How Diffie-Hellman Fails in Practice}

\bibitem{rfc2631} RFC 2631: \href{https://tools.ietf.org/html/rfc2631}{Diffie-Hellman Key Agreement Method}

\bibitem{rfc2785} RFC 2785: \href{https://tools.ietf.org/html/rfc2785}{Methods for Avoiding the "Small-Subgroup" Attacks on the Diffie-Hellman Key Agreement Method for S/MIME}

\bibitem{ecpp} Frank Li \href{http://theory.stanford.edu/~dfreeman/cs259c-f11/finalpapers/primalityproving.pdf}{An Overview of Elliptic Curve Primality Proving}

\bibitem{sicp} Abelson, Sussman, Sussman \href{https://mitpress.mit.edu/sicp/chapter1/footnode.html#2413}{Structure and Interpretation of Computer Programs}

\bibitem{tls12} RFC 5246: \href{https://www.ietf.org/rfc/rfc5246.txt}{The Transport Layer Security (TLS) Protocol Version 1.2}

\bibitem{fasterRSA} Shinde, Fadewar \href{http://www.techscience.com/doi/10.3970/icces.2008.005.255.pdf}{Faster RSA Algorithm for Decryption Using Chinese
Remainder Theorem}

\end{thebibliography}

\end{document}