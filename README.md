# How to backdoor Diffie-Hellman, lessons learned from the Socat non-prime prime

* This repo contains some research I'm currently doing on the Socat backdoor:
 - ![backdoor_generator.sage](backdoor_generator.sage) allows you to generate parameters for a DH backdoor
 - ![PoC.sage](PoC.sage) is a proof of concept (generation + simulation of attack)
 - ![socat_primes.sage](socat_primes.sage) contains old and new socat's primes
 - ![whitepaper.tex](whitepaper.tex) wannabe whitepaper
 
* [github/test_DHparams](https://github.com/mimoo/test_DHparams) contains a tool to check your Diffie-Hellman parameters (is the modulus long enough? Is it a safe prime? ...)

## Socat? What?

On February 1st 2016, a security advisory was posted to Openwall by a [Socat](http://www.dest-unreach.org/socat/) developer: [Socat security advisory 7 - Created new 2048bit DH modulus](http://www.openwall.com/lists/oss-security/2016/02/01/4)

> In the OpenSSL address implementation the hard coded 1024 bit DH p parameter **was not prime**. The effective cryptographic strength of a key exchange using these parameters was weaker than the one one could get by using a prime p. Moreover, since there is no indication of how these parameters were chosen, the existence of a trapdoor that makes possible for an eavesdropper to recover the shared secret from a key exchange that uses them cannot be ruled out.  
> A new prime modulus p parameter has been generated by Socat developer using OpenSSL dhparam command.  
> In addition the new parameter is 2048 bit long.

This is a pretty weird message with a [Juniper](http://forums.juniper.net/t5/Security-Incident-Response/Important-Announcement-about-ScreenOS/ba-p/285554) feeling to it. 

[Socat's README](http://www.dest-unreach.org/socat/doc/README) tells us that you can use their free software to setup an encrypted tunnel for data transfer between two peers.

Looking at the commit logs you can see that they used a 512 bits Diffie-Hellman modulus until last year (2015) january when [it was replaced with a 1024 bits one](http://repo.or.cz/socat.git/commitdiff/281d1bd6515c2f0f8984fc168fb3d3b91c20bdc0).

> Socat did not work in FIPS mode because 1024 instead of 512 bit DH prime is required. Thanks to Zhigang Wang for reporting and sending a patch.

The person who pushed the commit is *Gerhard Rieger* who is the same person who fixed it a year later. In the comment he refers to an Oracle employee at the time who has yet to comment on his mistake. It also seems like his github account and his personnal websites were deleted the day this security advisory was published.

This research's goal is to understand how this could possibly be a backdoor. And more particularly, a [Nobody-but-us](https://en.wikipedia.org/wiki/NOBUS) one (*NOBUS*). Here are the objectives of this research:

* Build a  [proof of concept](PoC.sage) of such a NOBUS backdoor
* check if we can reverse the socat backdoor to use it ourselve
* Try to answer the question: "does it look like a backdoor?"

# Human errors

How likely is it a human error?

* I've tried reversing the hex array representation of the modulus to see if the developer made a mistake, but nothing.

![reversed dh](http://i.imgur.com/L0VxosD.png)

* [Someone proposed](https://www.reddit.com/r/crypto/comments/43wh7h/the_socat_backdoor/czlxydf) something weird that I didn't understand. If someone wants to help me here.

# How to implement a NOBUS DH

There seem to be different ways, with different consequences, to do that. [backdoor_generator.sage](backdoor_generator.sage) allows you to generate backdoored DH parameters according to these different techniques, the explanations are in the source as well.

![backdoor generator menu](http://i.imgur.com/ReNnJ7U.png)

![backdoor generator result](http://i.imgur.com/klxlZpB.png)

There is also a working proof of concept in [PoC.sage](PoC.sage) that implements one way of doing it: 

It creates a non-prime modulus `p = p_1 * p_2` with `p_i` primes, such that
`p_i - 1` are smooth. Since the order of the group will be `(p_1 - 1)(p_2 - 1)` (smooth) and known only to the malicious person who generated `p`, *Pohlig-Hellman* (passive) or a *Small Subgroup Confinment attack* (active) can be used to recover the private key.

In the proof of concept the small subgroup attack is implemented instead of Pohlig-Hellman just because it seemed easier to code. They are relatively equivalent except that in practice an ephemeral key is used which makes small subgroup attacks not practical.

Note that these issues should not arrise if the DH parameters were generated properly, that is the order and subgroups orders should be known. If the prime is a safe prime, you don't need to do anything. If it is not, it might be that the order of the group (`p-1`) is smooth, this is a bad idea but nonetheless you can verify that the public key received lies in the correct subgroup by raising it to the power of the subgroup. See [rfc2785](https://tools.ietf.org/html/rfc2785) for more information.

![proof of concept](http://i.imgur.com/L7cNJP0.png)

The proof of concept is a step by step explanation of what's happening. Above you can see the generation of the backdoored modulus, bellow you can see the attack tacking place and recovering discrete logs of each of the subgroups

![discrete logs](http://i.imgur.com/kKgNjmh.png)

To run it yourself you will need Sage. You can also use an online version of it a [cloud.sagemath.com](http://cloud.sagemath.com).

## How to reverse socat's non-prime dh1024_p

from what we learned in implementing such a backdoor, we will see how we can reverse it to use it ourselves.

Trial division (testing every small primes up to a certain limit) has already found two small factors: 271 and 13,597. The last factor is still a composite of 1002 bits (302  digits) that we'll call C302 (C for Composite).

I tested if the generator (2) has order 271 or 13,597 or 271*13,597. But no.

Q: What are the chances that if this was non-prime was a mistake, it generated factors large enough so that no one can reverse it?

A: From Handbook of Applied Cryptography fact 3.7:

> Let n be chosen **uniformly at random** form the interval [1, x]
> 1. if 1/2 <= a <= 1, then the probability that the largest prime factor of n is <= x^a is approximately 1+ ln(a). Thus, for example, the probability than n has a prime factor > sqrt(x) is ln(2) ~= 0.69
> 2. The probability that the second-largest prime factor of n is <= x^{0.2117} is about 1/2
> 3. The expected total number of prime factors of n is ln ln x + O(1). (If n = mult(p_i^{e_i}), the total number of prime factors of n is sum(e_i).)

This means three things:

1. item socat's 1024 bit composite modulus `n` probability to have a prime factor greater than 512 bits is ~0.69.
2. the probability that the second-largest prime factor of `n` is smaller than 217 bits is 1/2.
3. The total number of prime factor of `n` is expected to be 7 (we already have 2).

217 bits is already too large a factor to find with ECM or p-1 factorization algorithm according to [ECM and p-1 records](http://www.loria.fr/~zimmerma/records/top50.html) (of 83 digits 3 years ago). It is largely do-able with GNFS (which records is of 768 bits). A discretelog modulo a 217 bits modulus is easy according to the [DLOG records](https://en.wikipedia.org/wiki/Discrete_logarithm_records) (of 596 bits 2 years ago). Logjam did tackle a 512 bits as well, in the matter of minutes, after months of pre-computing.

# What about socat's new prime dh2048_p's order

A new order has been generated, but we know nothing about its order: checking it with [test_DHparams](https://github.com/mimoo/test_DHparams) we confirm that it is a safe prime (`2q + 1`) so its order is implicit (`2q`).

![checking diffie hellman modulus](https://www.cryptologie.net/upload/Screen_Shot_2016-02-22_at_10.28_.42_PM_.png)

# Resources

* [Thai Duong's blogpost](http://vnhacker.blogspot.com/2016/02/exploiting-diffie-hellman-bug-in-socat.html)
* [crypto stackexchange's post](http://crypto.stackexchange.com/questions/32415/how-does-a-non-prime-modulus-for-diffie-hellman-allow-for-a-backdoor/32431?noredirect=1)
* [reddit's thread](https://www.reddit.com/r/crypto/comments/43wh7h/the_socat_backdoor/)
* [metzdowd's discussion](http://www.metzdowd.com/pipermail/cryptography/2016-February/028033.html)
